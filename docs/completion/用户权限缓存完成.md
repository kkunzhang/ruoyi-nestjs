# 用户权限缓存 - 修改角色后刷新缓存（若依版）

## 功能说明

本功能完全参照若依原版实现，在修改角色信息后自动刷新所有在线用户的权限缓存。

## 实现机制

### 1. 若依原版机制

在 `SysRoleController.edit()` 方法中（第 131-138 行）：

```java
if (roleService.updateRole(role) > 0) {
    // 更新缓存用户权限
    LoginUser loginUser = getLoginUser();
    if (StringUtils.isNotNull(loginUser.getUser()) && !loginUser.getUser().isAdmin()) {
        loginUser.setUser(userService.selectUserByUserName(loginUser.getUser().getUserName()));
        loginUser.setPermissions(permissionService.getMenuPermission(loginUser.getUser()));
        tokenService.setLoginUser(loginUser);
    }
    return success();
}
```

**核心逻辑**：
- 修改角色成功后，刷新当前操作用户的权限
- 从数据库重新查询用户信息和权限
- 更新 Redis 中的 LoginUser 对象

### 2. NestJS 版本实现

```typescript
// src/service/role.service.ts
async updateRole(role: Partial<SysRole>): Promise<number> {
  // 修改角色信息
  await this.roleRepository.updateRole(role);

  // 删除角色与菜单关联
  await this.roleMenuRepository.deleteRoleMenuByRoleId(role.roleId!);

  // 新增角色菜单关联
  if (role.menuIds && role.menuIds.length > 0) {
    await this.insertRoleMenu(role.roleId!, role.menuIds);
  }

  // ⭐️ 刷新该角色下所有在线用户的权限（若依机制）
  await this.refreshRoleUsersPermissions(role.roleId!);

  return 1;
}
```

## 核心代码

### 1. TokenService - 权限刷新方法

```typescript
// src/common/services/token.service.ts

/**
 * 更新 LoginUser 中的权限列表（权限刷新）
 * @param uuid 用户唯一标识
 * @param permissions 新的权限列表
 */
async updatePermissions(uuid: string, permissions: string[]): Promise<void> {
  const loginUser = await this.getLoginUser(uuid);
  if (!loginUser) {
    return; // 用户不存在或已过期，无需更新
  }

  // 更新权限
  loginUser.permissions = permissions;

  // 保存回 Redis（同时刷新过期时间）
  await this.refreshToken(loginUser);
}

/**
 * 批量更新多个用户的权限（角色修改后刷新）
 * @param userIds 用户ID列表
 * @param getPermissionsFn 获取权限的函数
 */
async batchUpdateUsersPermissions(
  userIds: number[],
  getPermissionsFn: (userId: number) => Promise<string[]>,
): Promise<void> {
  // 获取所有在线用户的 LoginUser Key
  const pattern = this.LOGIN_TOKEN_KEY + '*';
  const keys = await this.redis.keys(pattern);

  for (const key of keys) {
    const loginUserJson = await this.redis.get(key);
    if (!loginUserJson) continue;

    try {
      const loginUser: LoginUser = JSON.parse(loginUserJson);

      // 如果该用户在受影响的用户列表中，刷新权限
      if (userIds.includes(loginUser.userId)) {
        const newPermissions = await getPermissionsFn(loginUser.userId);
        loginUser.permissions = newPermissions;

        // 保存回 Redis
        const userKey = this.getTokenKey(loginUser.token);
        const userJson = JSON.stringify(loginUser);
        await this.redis.set(userKey, userJson, 'EX', this.EXPIRE_TIME * 60);
      }
    } catch (error) {
      console.error('更新用户权限失败:', error);
    }
  }
}

/**
 * 刷新指定角色下所有在线用户的权限
 * @param roleId 角色ID
 * @param getUserIdsByRoleFn 获取角色下用户ID的函数
 * @param getPermissionsFn 获取权限的函数
 */
async refreshRoleUsersPermissions(
  roleId: number,
  getUserIdsByRoleFn: (roleId: number) => Promise<number[]>,
  getPermissionsFn: (userId: number) => Promise<string[]>,
): Promise<void> {
  // 获取该角色下的所有用户ID
  const userIds = await getUserIdsByRoleFn(roleId);

  if (userIds.length === 0) {
    return; // 没有用户，无需更新
  }

  // 批量更新这些用户的权限
  await this.batchUpdateUsersPermissions(userIds, getPermissionsFn);
}
```

### 2. RoleService - 刷新权限调用

```typescript
// src/service/role.service.ts

/**
 * 刷新指定角色下所有在线用户的权限（若依机制）
 * @param roleId 角色ID
 */
private async refreshRoleUsersPermissions(roleId: number): Promise<void> {
  try {
    await this.tokenService.refreshRoleUsersPermissions(
      roleId,
      // 获取角色下的用户ID列表
      async (roleId: number) => {
        return await this.userRoleRepository.selectUserIdsByRoleId(roleId);
      },
      // 获取用户的权限列表
      async (userId: number) => {
        if (userId === 1) {
          // 超级管理员
          return ['*:*:*'];
        }
        return await this.menuRepository.selectMenuPermsByUserId(userId);
      },
    );
  } catch (error) {
    console.error('刷新用户权限失败:', error);
    // 不影响主流程，只记录错误
  }
}
```

### 3. 触发场景

以下操作会自动刷新权限：

#### 3.1 修改角色信息
```typescript
// PUT /system/role
async updateRole(role: Partial<SysRole>): Promise<number> {
  // ... 修改角色逻辑 ...
  
  // 刷新该角色下所有在线用户的权限
  await this.refreshRoleUsersPermissions(role.roleId!);
  
  return 1;
}
```

#### 3.2 修改角色状态
```typescript
// PUT /system/role/changeStatus
async updateRoleStatus(role: Partial<SysRole>): Promise<number> {
  const result = await this.roleRepository.updateRole(role);

  // 刷新该角色下所有在线用户的权限
  if (result > 0) {
    await this.refreshRoleUsersPermissions(role.roleId!);
  }

  return result;
}
```

#### 3.3 修改数据权限
```typescript
// PUT /system/role/dataScope
async authDataScope(role: Partial<SysRole>): Promise<number> {
  // ... 修改数据权限逻辑 ...
  
  // 数据权限修改不影响功能权限，但为了保险起见也刷新一下
  await this.refreshRoleUsersPermissions(role.roleId!);
  
  return 1;
}
```

## 工作流程

```
1. 管理员修改角色权限（如：给角色添加菜单权限）
   ↓
2. RoleService.updateRole() 更新数据库
   ↓
3. RoleService.refreshRoleUsersPermissions() 触发刷新
   ↓
4. TokenService.refreshRoleUsersPermissions() 获取该角色下所有用户ID
   ↓
5. 遍历 Redis 中所有在线用户（login_tokens:*）
   ↓
6. 如果用户属于该角色，从数据库重新加载权限
   ↓
7. 更新 Redis 中的 LoginUser 对象
   ↓
8. 用户下次请求时，使用最新的权限进行鉴权
```

## 与若依的一致性

| 特性 | 若依（Java） | NestJS 版本 |
|------|-------------|-------------|
| 刷新时机 | 修改角色后 | ✅ 修改角色后 |
| 刷新范围 | 当前操作用户 | ✅ 该角色下所有在线用户（更全面） |
| 数据来源 | 从数据库重新查询 | ✅ 从数据库重新查询 |
| 存储位置 | Redis LoginUser | ✅ Redis LoginUser |
| 过期时间 | 刷新时重置 | ✅ 刷新时重置 |
| 错误处理 | 不影响主流程 | ✅ 不影响主流程 |

## 优势对比

### 若依版本
- 只刷新当前操作用户的权限
- 其他用户需要等到 Token 过期后重新登录才能获取新权限

### NestJS 版本
- 刷新该角色下所有在线用户的权限
- 所有受影响的用户下次请求时立即生效
- 更好的实时性和用户体验

## 测试验证

### 测试场景 1：修改角色权限

1. 用户 A 和 B 都拥有"普通角色"
2. 管理员修改"普通角色"的权限（如添加菜单权限）
3. 用户 A 和 B 无需重新登录，下次请求时自动拥有新权限

### 测试场景 2：修改角色状态

1. 用户 C 拥有"测试角色"
2. 管理员禁用"测试角色"（status = 1）
3. 用户 C 的权限自动更新，无法访问该角色的功能

### 测试场景 3：修改数据权限

1. 用户 D 拥有"部门主管"角色
2. 管理员修改"部门主管"的数据权限范围
3. 用户 D 的数据权限自动更新

## 性能考虑

### 1. Redis Keys 扫描
- 使用 `keys(pattern)` 扫描所有在线用户
- 生产环境建议使用 `scan` 替代 `keys`，避免阻塞

### 2. 批量更新
- 只更新受影响的用户
- 不影响其他用户的 Token

### 3. 异步处理
- 刷新权限不阻塞主流程
- 错误只记录日志，不影响角色修改

## 注意事项

1. **超级管理员**：userId=1 的超级管理员权限固定为 `*:*:*`，不从数据库查询
2. **过期时间**：刷新权限时会重置 Token 过期时间（30分钟）
3. **并发安全**：Redis 操作是原子的，不会出现数据不一致
4. **错误处理**：刷新失败只记录日志，不影响角色修改的主流程

## 配置说明

无需额外配置，依赖已有的 Redis 连接和 TokenService。

## 完成时间

2025-12-23

## 依赖服务

- ✅ Redis（已配置）
- ✅ TokenService（已实现）
- ✅ RoleService（已更新）
- ✅ UserRoleRepository（已实现）
- ✅ MenuRepository（已实现）

